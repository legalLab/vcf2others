#' @title vcf2arlequin
#' @description converts vcfR format data to Arlequin infile
#' @description in part based on vcfR2migrate function (vcfR package)
#' @author Tomas Hrbek December 2020
#'
#' @param vcf -> vcfR object
#' @param ind_pop -> population assignment of individuals in vcf (factor)
#' @param keep_pop -> population(s) of interest to include in Arlequin infile (factor)
#' @param inc_missing -> include missing data (logical)
#' @param out_file -> name of file to output (Arlequin infile)
#' @export
#' @return nothing
#'
#' @details
#' This function converts the vcfR object to a Arlequin formatted input file
#' The function will remove indels, and multiallelic loci, and optionally loci with missing data
#'
#' @examples
#' vcf2arlequin(vcf = my_vcf, ind_pop = ind_pop, keep_pop = keepers, inc_missing = TRUE, out_file = "Arlequin_infile.arp")
#' vcf2arlequin(my_vcf, ind_pop, keepers, out_file = "Arlequin_infile.arp")
#' vcf2arlequin(my_vcf, ind_pop, keepers)
#'

vcf2arlequin <-function (vcf, ind_pop, keep_pop, inc_missing = TRUE, out_file = "arlequin.arp")
{
  if (class(vcf) != "vcfR") {
    stop(paste("Expecting an object of class vcfR, received a",
               class(vcf), "instead"))
  }
  if (class(ind_pop) != "factor" | class(keep_pop) != "factor") {
    stop(paste("Expecting population vector, received a",
               class(ind_pop), "and", class(keep_pop), "instead"))
  }
  vcf <- vcfR::extract.indels(vcf, return.indels = FALSE)
  vcf <- vcf[vcfR::is.biallelic(vcf), ]
  if (inc_missing == FALSE) {
    gt <- vcfR::extract.gt(vcf, convertNA = TRUE)
    vcf <- vcf[!rowSums(is.na(gt)), ]
  }
  vcf_list <- lapply(keep_pop, function(x) {
    vcf[, c(TRUE, x == ind_pop)]
  })
  names(vcf_list) <- keep_pop
  pop_list <- vector(mode = "list", length = length(vcf_list))
  names(pop_list) <- names(vcf_list)

  for (i in seq_along(vcf_list)) {
    gt <- vcfR::extract.gt(vcf_list[[i]], return.alleles = FALSE, convertNA = TRUE) %>%
      tibble::as_tibble()

    allele1 <- arrow::as_arrow_table(gt) %>%
      dplyr::mutate(across(everything(), ~ if_else(is.na(.), "?/?", .))) %>%
      dplyr::mutate(across(everything(), ~ substr(., 1, 1))) %>%
      dplyr::collect() %>%
      t() %>%
      as.data.frame()
    rownames(allele1) <- paste0(rownames(allele1), "_1")

    allele2 <- arrow::as_arrow_table(gt) %>%
      dplyr::mutate(across(everything(), ~ if_else(is.na(.), "?/?", .))) %>%
      dplyr::mutate(across(everything(), ~ substr(., 3, 3))) %>%
      dplyr::collect() %>%
      t() %>%
      as.data.frame()
    rownames(allele2) <- paste0(rownames(allele2), "_2")

    pop_list[[i]][[1]] <- allele1
    pop_list[[i]][[2]] <- allele2
  }

  write("[Profile]", file = out_file)
  write("", file = out_file, append = TRUE)
  write("Title = 'Generated by vcf2arlequin {vcf2others}'", file = out_file, append = TRUE)
  write(paste("NbSamples = ", length(vcf_list), sep = ""), file = out_file, append = TRUE)
  write("GenotypicData = 1", file = out_file, append = TRUE)
  write("LocusSeparator = WHITESPACE", file = out_file, append = TRUE)
  write("GameticPhase = 0", file = out_file, append = TRUE)
  write("MissingData = '?'", file = out_file, append = TRUE)
  write("DataType = STANDARD", file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  write("[Data]", file = out_file, append = TRUE)
  write("[[Samples]]", file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  write(paste("#There are ", nrow(vcf), " SNPs", sep = ""), file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)

  for (i in seq_along(pop_list)) {
    write(paste0("SampleName = ", "'", names(pop_list)[i], "'"), file = out_file, append = TRUE)
    write(paste0("SampleSize = ", nrow(pop_list[[i]][[1]])), file = out_file, append = TRUE)
    write("SampleData={", file = out_file, append = TRUE)

    for (j in 1:nrow(pop_list[[i]][[1]])) {
      utils::write.table(t(c(names(pop_list[[i]][[1]][j, 1]), "\t1\t", pop_list[[i]][[1]][j, ])), file = out_file,
                         append = TRUE, quote = FALSE, sep = "\t", row.names = FALSE,
                         col.names = FALSE)
      utils::write.table(t(c("\t\t\t\t\t", pop_list[[i]][[2]][j, ])), file = out_file,
                         append = TRUE, quote = FALSE, sep = "\t", row.names = FALSE,
                         col.names = FALSE)
    }
    write("}", file = out_file, append = TRUE)
    write("", file = out_file, append = TRUE)
  }

  write("[[Structure]]", file = out_file, append = TRUE)
  write("StructureName = 'One Group'", file = out_file, append = TRUE)
  write("NbGroups = 1", file = out_file, append = TRUE)
  write("", file = out_file, append = TRUE)
  write("Group = {",  file = out_file, append = TRUE)
  for (i in 1:length(names(pop_list))) {
    write(paste0("\t\t", "\"", names(pop_list)[i], "\""),  file = out_file, append = TRUE)
  }
  write("}",  file = out_file, append = TRUE)

  invisible(vcf)
}
